{
  "ingest_run_id": "cc070d93402b9558449000c99046aad73264aa88",
  "repo_ref": "redis/redis",
  "commit_sha": "53e4631e7935a31376bf00b59db99b09322dcca8",
  "section_count": 6,
  "subsection_count": 18,
  "total_korean_chars": 0,
  "source_doc_count": 24,
  "trend_fact_count": 8,
  "draft": {
    "artifactType": "wiki-draft",
    "repoFullName": "redis/redis",
    "commitSha": "53e4631e7935a31376bf00b59db99b09322dcca8",
    "generatedAt": "2026-02-24T10:20:00.000Z",
    "overviewKo": "Redis 코드는 단일 저장소 안에서 실행 엔진, 클러스터, 복제, 영속성, 모듈 API를 동시에 운용하도록 설계되어 있습니다. `redis-server`는 기동과 상태 복구를 주관하고, `redis-cli`는 사용자가 조작한 요청을 서버로 전달하는 진입점입니다. 진입점만 바꾸는 것처럼 보여도 실제 영향은 영속성 정책(`src/rdb.c`, `src/aof.c`), 라우팅 정책(`src/cluster.c`), 복제 동기화(`src/replication.c`), 명령 테이블(`src/commands.c`) 전체로 전파됩니다. 초보자에게는 \"먼저 어디를 읽을지\"가 관건이므로, 저장소를 \"실행 경로, 데이터 경로, 문서/트렌드 근거\"의 세 레이어로 나눠 이해하면 변경 판단이 빨라집니다. 본 문서는 `README.md`, `tests/README.md`, `src/server.c`, `src/rdb.c`, `src/aof.c`, `__devport__/trends/*`를 통해 6개 섹션으로 핵심을 정리합니다.",
    "sections": [
      {
        "sectionId": "sec-1",
        "titleKo": "입문자 빠른 시작과 저장소 지도",
        "summaryKo": "이 섹션은 저장소 전체 탐색의 시작점입니다. `README.md`, `src/server.c`, `src/redis-cli.c`, `tests/README.md`를 중심으로 진입점과 의존성을 먼저 정렬해 이후 아키텍처 분석의 기준점을 잡습니다.",
        "sourcePaths": [
          "README.md",
          "src/commands/README.md",
          "src/redis-cli.c",
          "src/server.c",
          "tests/README.md",
          "deps/README.md"
        ],
        "subsections": [
          {
            "sectionId": "sec-1",
            "subsectionId": "sub-1-1",
            "titleKo": "입문자 빠른 시작과 저장소 지도 - 구조와 책임",
            "objectiveKo": "핵심 진입점과 파일군을 빠르게 파악해, 어떤 파일을 먼저 읽어야 하는지 판단한다.",
            "bodyKo": "`README.md`는 Redis의 실행 대상 독자군을 가이드하는 첫 지도입니다. 설치 방식, 실행 옵션, 기본 운영 예시가 정리되어 있어 어떤 파일이 먼저 보아야 하는지의 우선순위를 이미 제시합니다. 그런데 실제 소스 탐색을 시작하려면 `src/server.c`와 `src/redis-cli.c`를 같이 봐야 합니다. `src/server.c`는 서버 기동과 이벤트 루프, 커넥션 수락, 영속성 복원, 모듈 준비를 담당하는 제어면이고, `src/redis-cli.c`는 실제 사용자가 터미널에서 보내는 커맨드를 서버형식으로 변환하는 입력면이기 때문입니다.\n\n초보자 지형도는 아래 4개 축으로 나눌 수 있습니다. 첫째, 실행 축: `src/server.c`와 `src/config.c`에서 초기화 흐름과 설정 해석을 본다. 둘째, 명령 축: `src/commands/README.md`와 `src/commands.c`에서 커맨드 인터페이스를 본다. 셋째, 데이터 축: `src/rdb.c`, `src/aof.c`, `src/replication.c`로 영속성과 장애복구 흐름을 본다. 넷째, 검증 축: `tests/README.md`와 주요 `tests/*` 파일에서 회귀 범위를 본다. 이 4축을 먼저 잡으면 `redis-server`의 동작이 모노리포에서 어디로 갈라지는지 감이 생깁니다.\n\n`deps`와 `__devport__` 경로는 초보자에게 방해물이 아니라 실제 운영 판단에 필요한 신호입니다. `deps`는 외부 의존성 빌드 정책과 플랫폼 편차를 관리하고, `__devport__/trends/*`는 릴리스 속도와 공개 태그 정보를 보여 줍니다. 특히 파일 수가 방대할수록 공백으로 놓치기 쉬운 건 \\"어떤 문서가 지금 기준점인지\\"인데, 공식/트렌드 파일은 이 점을 보완합니다.\n\n실제 학습 순서는 추천합니다. 먼저 `README.md`에서 실행과 배포 전제를 확인하고, 그다음 `src/server.c`를 열어 `main` 진입부터 `initServer()` 직전까지의 상태를 훑습니다. 그다음 바로 `src/redis-cli.c`로 들어가 입력/출력 경계를 읽은 뒤, `src/commands/README.md`에서 노출된 명령군을 대조하면 구조가 안정됩니다. 이 단계가 끝나면 `tests/README.md`에서 어느 레이어를 바꿨을 때 어느 테스트가 깨질지 추론할 수 있습니다.\n\n요약하면 sec-1의 핵심은 \\"문서-실행-명령-검증\\"의 탐색 순서를 고정하는 것입니다. 이 순서가 잡히면 이후 섹션에서 `cluster`와 `persist`를 따로 공부할 때도 전체 맥락이 무너지지 않습니다."
          },
          {
            "sectionId": "sec-1",
            "subsectionId": "sub-1-2",
            "titleKo": "입문자 빠른 시작과 저장소 지도 - 실행/데이터 흐름",
            "objectiveKo": "실행 시 명령이 어디를 거쳐 데이터 처리로 연결되는지 추적한다.",
            "bodyKo": "Redis는 사용자가 입력한 요청이 즉시 데이터베이스로 반영되는 것처럼 보이지만, 실제로는 단계가 나뉘어 있습니다. 서버 실행은 `src/server.c`에서 `main` 진입 후 전역 설정(`initServerConfig`)과 리소스 초기화(`initServer`)를 거쳐 시작되고, 네트워크와 이벤트 루프가 준비되면서 커맨드 수신이 가능해집니다. 이 시점이 `redis-cli`에서 보내는 문자열형 요청과 매칭되는 첫 경계입니다.\n\n`src/redis-cli.c`는 요청을 텍스트로 구성하고 서버가 이해할 수 있는 프로토콜로 보냅니다. 응답은 콘솔 출력/배치 출력 형태로 되돌아오는데, 이것이 사용자 체감의 상단층입니다. 실제 핵심 작업은 그 아래에서 `src/commands.c`가 수행됩니다. 여기서 커맨드 이름 정규화, 인자 파싱, 핸들러 바인딩이 이뤄져 실제 연산 함수로 넘어갑니다.\n\n이후 데이터 처리 경로는 단일 데이터 구조가 아니라 요청 성격별로 갈래가 갈립니다. 단순 읽기/쓰기 명령은 즉시 메모리 상태를 변경하고 응답을 작성하지만, 클러스터 모드라면 `src/cluster.c`에서 슬롯과 키 위치, 리다이렉트 정책을 확인한 후 응답이 재라우팅될 수 있습니다. `MOVED`와 `ASK`는 실패가 아니라 목적지 안내로, 요청이 틀린 점이 아니라 라우팅 경계일 가능성이 큽니다. 복제 구성일 때는 `replication` 관점으로의 분기가 추가되어, 쓰기 결과가 추후 전달될 보류 경로가 생깁니다.\n\n입문자에게 중요한 포인트는 \\"요청 시작과 데이터 영속성의 분리\\"입니다. 요청이 들어오는 즉시 영속성 파일을 동시에 건드리는 것이 아니라, 메모리 변경 후 백그라운드/비동기 경로가 데이터를 확정합니다. 이 동작은 `src/rdb.c`, `src/aof.c`, 복제 관련 함수와 묶여 있으며, 장애 복구 시 `src/server.c`의 `loadDataFromDisk` 경로와 연결됩니다.\n\n실습 순서는 명확합니다. 먼저 CLI 한두 개 명령을 돌려 보고, 같은 동작을 클러스터 환경과 비교하고, 마지막으로 `tests`에서 동일 패턴이 어떻게 검증되는지 확인합니다. 같은 명령이 다른 경로로 처리되는 지점이 보이면 초보자일수록 정확히 \\"왜 그 경로가 선택되었는지\\"만 확인하면 됩니다.\n\n이 흐름을 한 문장으로 정리하면, Redis 실행은 \\"요청 수신 -> 커맨드 바인딩 -> 라우팅/보정 -> 상태 변경 -> 비동기 동기화\\"로 이루어지고, 모든 변경의 진입은 `src/server.c`와 `src/commands.c`가 결합된 경계에서 시작됩니다."
          },
          {
            "sectionId": "sec-1",
            "subsectionId": "sub-1-3",
            "titleKo": "입문자 빠른 시작과 저장소 지도 - 검증과 변경 포인트",
            "objectiveKo": "초반 탐색 단계에서 흔히 발생하는 수정 실수를 예방하는 체크포인트를 만든다.",
            "bodyKo": "초기 탐색에서 가장 위험한 실수는 실행 동작과 문서 설명의 단절입니다. 파일 하나를 수정했을 때 커맨드 테스트, 통합 테스트, 문서 예제가 모두 따라가지 않으면 사용자는 오류를 먼저 보게 되고, 코어 수정자는 원인 규명이 늦어집니다. 따라서 변경 전에는 `src/server.c`, `src/config.c`, `src/commands.c`의 경계 변화가 기존 테스트 문구와 충돌하지 않는지를 먼저 확인하는 습관이 필요합니다.\n\n`tests/README.md`를 보면 테스트가 어느 축으로 구성되어 있는지 바로 확인할 수 있습니다. `tests/unit`은 기능 동작의 단위 정합성을 담당하고, `tests/integration`은 실제 실행 환경에서의 동시성, 복제, 노드 이동을 다룹니다. 따라서 명령 파싱이나 응답 형식을 바꾸는 것은 단위 테스트를 먼저 확인하고, 복제/클러스터/영속성 관련 변경은 반드시 통합 테스트까지 함께 돌려야 합니다. 여기서 `tests/unit/stream.tcl`, `tests/unit/acl.tcl` 같은 파일을 고르면 인증, 접근 제어, 키 공간 동작까지 동시에 건드릴 수 있음을 알 수 있습니다.\n\n`deps`는 단순 외부 라이브러리 모음이 아니라 빌드 체인과 성능 성격을 바꾸는 경계입니다. `deps/jemalloc`의 메모리 정책 변화는 실행 특성에 직접적인 영향을 주고, `deps/hiredis`와의 변경은 클라이언트 라이브러리 인터페이스 관측에 영향을 줄 수 있습니다. 초보자가 이 지점들을 무시하면 설정 하나가 성능 이상 징후로 해석되는 오해를 낳기 쉽습니다.\n\n`__devport__/trends/*`는 트렌드 기반 검증 근거로도 유용합니다. 최근 릴리스가 어떻게 구성됐는지 보고 현재 코드 베이스에서 새 포맷이나 새 기능이 이미 어디까지 반영됐는지 비교하면, 로컬 변경이 실제 릴리스 흐름과 잘 맞는지 가늠하기 좋습니다. 문서 갱신과 코드 갱신 사이의 간격은 코드 안정성보다 운영 이슈를 빠르게 만든다는 점을 기억해야 합니다.\n\n변경 포인트를 정리하면 3개입니다. 1) 설정 기본값 변경 전후로 관련 테스트 스위트 점검, 2) 응답 포맷 변경 시 CLI 및 문서 예제 동시 확인, 3) 클러스터/복제 동작이 개입되는 변경이면 통합 테스트를 병행. 이 3개만 지켜도 초보 단계에서의 실수율이 크게 줄어듭니다.\n\nsec-1의 핵심은 \\"변경 전 맥락\\"입니다. Redis는 파일이 많아서 모든 파일을 동시에 읽기보다, 먼저 진입점-커맨드-테스트를 묶어 본 뒤 확장 항목으로 이동하는 방식이 안정적입니다."
          }
        ]
      },
      {
        "sectionId": "sec-2",
        "titleKo": "실행 아키텍처와 핵심 호출 흐름",
        "summaryKo": "이 섹션은 실행 계층의 호출 흐름을 분해합니다. `src/server.c`와 `src/config.c`, `src/commands.c`, `src/cluster.c`를 통해 서버 기동부터 커맨드 처리, 라우팅까지의 경계를 정리합니다.",
        "sourcePaths": [
          "src/server.c",
          "src/config.c",
          "src/commands.c",
          "src/cluster.c",
          "__devport__/official-docs/index.json",
          "src/module.c"
        ],
        "subsections": [
          {
            "sectionId": "sec-2",
            "subsectionId": "sub-2-1",
            "titleKo": "실행 아키텍처와 핵심 호출 흐름 - 구조와 책임",
            "objectiveKo": "아키텍처 계층과 함수 호출 책임을 계층별로 정리한다.",
            "bodyKo": "Redis 실행 경로에서 가장 먼저 보아야 하는 함수군은 `src/server.c`의 기동/정합성 계층입니다. 진입부에서는 `initServerConfig()`로 설정을 정규화하고, `initServer()`에서 네트워크 핸들러, 백그라운드 cron, 커맨드 테이블, 모듈 등록을 준비합니다. 이 단계는 \\"서비스가 살아있는 상태\\"를 만드는 핵심이고, 여기서 무너진다면 모든 상위 기능이 연쇄 실패합니다.\n\n그 다음에는 명령 라우팅의 진입점으로 이동합니다. `src/commands.c`는 각 커맨드가 실제 핸들러 함수와 연결되는 계약을 제공하고, 인자 체크와 에러 맵핑 규칙을 통일합니다. `redis-server`가 소켓에서 문자열을 받는 순간부터 이 계층을 지나야 데이터가 실제 연산 상태로 바뀌며, 그러므로 커맨드 테이블 정합성은 성능보다 우선되는 안정성 규칙입니다.\n\n클러스터 모드에서는 추가 계층이 `src/cluster.c`로 붙습니다. 슬롯 계산과 이동 경로 판단이 먼저 이뤄지며, 대상 노드 이동이 필요하면 리다이렉트 응답을 내려주어 상위 라우팅 경로를 명시합니다. 이때 동일 명령이라도 노드별 상태에 따라 응답이 다르게 보일 수 있으니, 요청 자체의 정합성보다 슬롯/메타데이터 상태를 먼저 점검해야 합니다.\n\n모듈 API가 관여하는 경우, `src/module.c`가 플러그인 등록과 명령 확장을 수용하고 실행 진입을 보조합니다. 모듈이 추가한 명령은 기본 커맨드 테이블과 같은 호출 규약을 공유하지만, 내부적으로는 모듈이 가진 초기화/종료 훅에 따라 실행 범위가 달라집니다. 이 구조를 놓치면 \\"명령은 등록됐는데 동작이 안 된다\\"는 증상이 자주 발생합니다.\n\n실행 아키텍처를 정리하면, `src/server.c`가 프로세스 생명주기를 관리하고, `src/commands.c`가 외부 요청 인터페이스를 보장하며, `src/cluster.c`가 분산 라우팅을 제어하고, `src/module.c`가 확장을 주입하는 4단 구조라고 볼 수 있습니다. 이 4단을 기억하면 장애를 볼 때도 어느 모듈의 책임인지 빠르게 추정할 수 있습니다.\n\n초보자에게 추천하는 첫 추적 순서는 \\"설정->기동->명령->라우팅->모듈\\"입니다. 설정이 변경된 시점, 기동 단계의 알림 로그, 명령 처리 결과, 리다이렉트 여부를 같은 세션에서 비교하면 아키텍처의 상태를 빠르게 디버깅할 수 있습니다. 따라서 섹션 2 전체의 핵심은 호출 사슬의 계층이 어디에서 열리고 어디에서 닫히는지 감을 잡는 것입니다."
          },
          {
            "sectionId": "sec-2",
            "subsectionId": "sub-2-2",
            "titleKo": "실행 아키텍처와 핵심 호출 흐름 - 실행/데이터 흐름",
            "objectiveKo": "요청 경로가 네트워크 수신에서 실행 완료까지 어떻게 이동하는지 추적한다.",
            "bodyKo": "실행 요청은 단일 트랜잭션처럼 보이지만, 내부적으로는 여러 경로 검사를 통과해 처리됩니다. 아래 그림은 기본적인 흐름을 단순화한 것입니다.\n\n```mermaid\nflowchart TD\nA[redis-cli/네트워크 입력] --> B[request parser\nsrc/commands.c]\nB --> C[command dispatch]\nC --> D{cluster mode?\nsrc/cluster.c}\nD -->|no| E[local execution\nsrc/commands.c]\nD -->|yes| F[routing decision\nASK/MOVED]\nF --> G[proxy/redirect]\nE --> H[command handler in src/*]\nH --> I{writes?}\nI -->|yes| J[persistence hooks\nsrc/rdb.c, src/aof.c]\nI -->|no| K[reply build]\nJ --> K\nK --> L[resp writer]\nL --> M[client response]\n```\n\n위 도식에서 핵심은 실제 작업자는 `src/commands.c` 내부 또는 연결 핸들러라고 해도 데이터 계층은 `src/rdb.c`, `src/aof.c`, `src/replication.c`에서 이어집니다. 특히 쓰기 계열 요청은 응답을 끝내기 전에 영속성 경로가 개입되는지, 나중 비동기로 떨어지는지 확인해야 운영자가 지연 특성을 정확히 예측할 수 있습니다. Redis는 요청 처리와 복제 전파가 긴밀히 연결돼 있어, \\"요청 완료\\"와 \\"요청 신뢰성 확보\\"가 같은 시점에 일어나지 않을 수 있습니다.\n\n네트워크 계층으로 되돌아가면, 단일 요청이 연결 이벤트에서 출발해 이벤트 루프를 지나면 실제 핸들러로 들어갑니다. 핸들러는 상태를 변경했을 수 있고, 클러스터 모드면 라우팅 분기를 거치거나 재시도 흐름이 걸립니다. 그리고 쓰기 요청이면 데이터 보존 경로로 추가되어 `appendonly` 또는 snapshot 갱신이 트리거될 수 있습니다. 이 구조를 모르면 \\"명령은 즉시 성공했는데 영속성은 안 된다\\"는 오해가 생깁니다.\n\n예외는 장애 복구에서 더 두드러집니다. 노드 부팅시 `loadDataFromDisk()` 경로로 RDB/AOF를 복구하고, 이후 다시 복제 동기화를 구성해 서비스 상태를 맞춥니다. 즉, 실행 시에는 한 번, 복구 시에는 다시 한 번 동일 데이터 구조를 읽는 과정이 일어나므로, 운영 모니터링에서는 재시작 이벤트를 단순 기동 로그로만 보지 말아야 합니다.\n\n실행 데이터 흐름을 점검할 때는 단일 명령 테스트보다 상태 전환 시나리오를 추천합니다. 새 설정으로 기동 -> 커맨드 실행 -> 리다이렉트 발생 -> 복구 기동을 같은 순서로 재현하면 계층의 경계가 드러납니다. 이때 결과가 모순되면 가장 먼저 cluster 라우팅과 module 바인딩을 점검합니다.\n\n섹션 2-2의 결론은 간단합니다. 요청은 네트워크로 들어와 커맨드 파서와 라우팅을 거쳐, 쓰기면 영속성 훅이 추가된 뒤 응답이 완성되는 흐름입니다. mermaid 다이어그램의 각 노드는 실제 파일군으로 매핑되므로 코드를 열어보면 경로 추적이 빠르게 성립합니다."
          },
          {
            "sectionId": "sec-2",
            "subsectionId": "sub-2-3",
            "titleKo": "실행 아키텍처와 핵심 호출 흐름 - 검증과 변경 포인트",
            "objectiveKo": "아키텍처 변경 시 실패 전파 경로를 예측 가능한 규칙으로 관리한다.",
            "bodyKo": "아키텍처 변경에서 가장 위험한 지점은 호출 경로 끝부분이 아니라 시작점입니다. `src/server.c` 기동부를 수정하면 `src/config.c`, `src/commands.c`, 심지어 `src/cluster.c`까지 영향을 받을 수 있기 때문입니다. 예를 들어 기본 설정 하나가 바뀌면 커맨드 허용 범위가 달라지고, 이것이 리다이렉트 정책과 결합하면 클러스터 분기 결과가 달라지는 사례가 자주 생깁니다. 따라서 변경 전후에는 \\"기동->명령->라우팅\\"의 세 경계를 동시에 점검합니다.\n\n검증 계획은 3층으로 구성할 수 있습니다. 1층은 코드 레벨에서 컴파일/단위 동작(명령 파서/기본 응답)을 점검합니다. 2층은 분산/노드 레이어로, 동일 요청이 슬롯 이동과 리다이렉트에서 어떻게 반응하는지 확인합니다. 3층은 영속성/복제 레이어로, 쓰기 요청이 재시작 후 동일하게 재현되는지 본다는 점입니다. 이 3층을 순차적으로 보면 아키텍처 변경의 영향이 어디서 생기는지 빠르게 좁혀집니다.\n\n많은 분쟁이 `MOVED`와 `ASK`를 동일하게 취급해 생깁니다. 두 응답은 둘 다 리다이렉트이지만 정책의 의미가 다르므로, 클러스터 설정이 약간만 바뀌어도 클라이언트의 재시도 패턴이 완전히 달라집니다. Redis의 실행 아키텍처는 이런 미묘함을 커버할 수 있어야 하며, 이는 클라이언트 라이브러리와 모듈까지 연결되는 문제이기 때문에 CLI에서만 확인하면 안 됩니다.\n\n모듈 경로도 변경 포인트입니다. `src/module.c`의 명령 등록이 기존 커맨드 규약을 바꾸거나 이름 충돌을 만들면 `src/commands.c`의 라우터가 다른 함수로 가거나 아예 분기하지 않을 수 있습니다. 모듈 변경 후에는 등록 로그와 실제 실행 로그를 함께 본 뒤, 기존 내장 명령과 경합이 없는지 점검해야 합니다.\n\n코드베이스가 크고 변경이 잦을수록 실수는 \\"정적 테스트 통과\\" 뒤에 드러나는 경우가 많습니다. 따라서 `build` 성공과 테스트 통과가 끝이라 생각하기보다 운영 동작(리다이렉트 발생 빈도, 복구 후 데이터 정합성, 노드 이동 지연)을 별도로 모니터링하는 습관이 필요합니다.\n\nsec-2 마지막 포인트는 기준점 문서화입니다. 어떤 변경이라도 어떤 단계에서 어느 결과를 기대하는지 `draft`에 기록해 두면 다음 개발자가 재현할 때 속도가 크게 올라갑니다. 이것이 아키텍처 변경 시 품질 게이트의 핵심입니다."
          }
        ]
      },
      {
        "sectionId": "sec-3",
        "titleKo": "핵심 기능 구현과 데이터 경로",
        "summaryKo": "이 섹션은 데이터 저장, 복제, 모듈 확장 경로를 통합해 다루며 요청 데이터가 어떤 함수군을 거치며 영속성 상태로 넘어가는지 설명합니다.",
        "sourcePaths": [
          "src/rdb.c",
          "src/aof.c",
          "src/replication.c",
          "src/module.c",
          "src/commands/README.md"
        ],
        "subsections": [
          {
            "sectionId": "sec-3",
            "subsectionId": "sub-3-1",
            "titleKo": "핵심 기능 구현과 데이터 경로 - 구조와 책임",
            "objectiveKo": "데이터 저장/복제/모듈 경로를 하나의 흐름으로 통합해 본다.",
            "bodyKo": "Redis의 핵심은 데이터가 메모리에서 시작해, 필요할 때 영속성·복제·클러스터 경계로 이동한다는 점입니다. 이 흐름의 첫 단계는 커맨드 처리이며, 실제 저장은 `src/rdb.c`와 `src/aof.c`를 통해 데이터베이스 상태가 오래 보존되도록 확정됩니다. `src/rdb.c`는 스냅샷 형식 직렬화, `src/aof.c`는 변경 로그의 증분 기록을 담당해 각기 다른 회복 특성을 제공합니다.\n\n`src/rdb.c` 안에서 `rdbSave*`와 `rdbLoad*` 시리즈는 바이너리 포맷의 인코딩 규약과 버전 호환을 지키며 동작합니다. 데이터 타입별 저장 방식, keyspace 탐색, expire TTL 처리, stream·hash·zset 같은 복합 타입 처리까지 포함되어 있어, 하나의 함수군에서 복수의 자료 구조 계약이 동시에 유지됩니다. 따라서 `rdbSave` 경로를 바꾸면 단순한 파일 크기 변화가 아니라 복원 시점의 데이터 해석 방식 자체가 달라질 수 있으므로 매우 민감한 영역입니다.\n\n`src/aof.c`는 변경 로그를 기록하는 경로에서 `bgrewrite` 같은 리프레시 동작까지 다룹니다. 즉, `append-only`는 단순 append만이 아니라 로그 압축, 히스토리 정리, 비정상 종료 후 재생 안전성까지 함께 봐야 합니다. 실제 운영에서 작은 데이터 손실 위험을 줄이는 핵심은 AOF 정책과 RDB 정책을 동시에 봐야 한다는 점이며, 두 모드의 상태가 서로 독립적으로 보이지만 운영 시점에는 상호 의존성을 이룹니다.\n\n복제 경로는 `src/replication.c`로 이어집니다. `startBgsaveForReplication()`이나 `rdbSaveToSlavesSockets()`는 마스터-슬레이브 동기화의 데이터 전달을 다루며, 네트워크 환경에서는 단순 복제가 아니라 전달 상태와 누락 방지 상태가 함께 유지됩니다. `masterTryPartialResynchronization()`는 부분 동기화 재연결 경로에서 네트워크 지연과 전송량을 줄이는 핵심 규칙을 결정합니다. 따라서 복제 안정성은 영속성 단일 정책보다 훨씬 넓은 맥락을 포함합니다.\n\n모듈 경로는 `src/module.c`에서 실행 환경과 결합됩니다. `RM_CreateDataType`, `RM_RegisterCommand` 같은 API는 Redis가 제공하는 내부 오브젝트 표준을 그대로 따르게 강제해, 외부 모듈이 내부 상태 규약을 깨지 않게 합니다. 모듈이 잘못 등록되면 저장 포맷과 무관하게 커맨드 경로 또는 메모리 관리에서 즉시 문제가 생길 수 있어 주의가 필요합니다.\n\nsec-3에서는 핵심 기능을 요청 데이터 경로와 영속성 경로의 결합으로 봐야 합니다. 커맨드가 내부 상태를 바꾸면 해당 데이터는 메모리 + 로그/스냅샷 + 복제 흐름으로 동시 반영되며, 따라서 \\"한 함수만 건드린다\\"는 발상은 항상 위험합니다."
          },
          {
            "sectionId": "sec-3",
            "subsectionId": "sub-3-2",
            "titleKo": "핵심 기능 구현과 데이터 경로 - 실행/데이터 흐름",
            "objectiveKo": "실제 객체 저장과 로딩이 어떤 단계에서 발생하는지 추적한다.",
            "bodyKo": "데이터 경로는 요청 진입 시점에서 메모리 조작으로 이동하고, 쓰기/수정 동작 끝에서 저장 경로를 거쳐 영속성과 동기화 경로로 넘어갑니다. 이 과정에서 빠뜨리기 쉬운 점은 \\"실제 디스크 반영이 언제 트리거되는가\\"입니다. Redis는 응답을 즉시 반환할 수 있어도 디스크 반영은 지연될 수 있으며, `src/aof.c`와 `src/rdb.c`가 서로 다른 보존 모델로 작동합니다.\n\n`rdb` 경로는 특정 시점의 상태를 통째로 캡처하는 성질이 강합니다. 백그라운드 저장이 트리거되면 대상 파일 형식과 버전, 길이 계산, 키 타입 스키마가 일관되게 직렬화되어야 하며, 그때 쓰이는 타입 코드와 메타데이터가 복구의 기반이 됩니다. 반면 `aof` 경로는 변경 로그의 순서를 따라 재생되는 모델이라 장애 직후 복구 시점이 다른 결과를 만듭니다.\n\n`src/replication.c`는 이 두 모델을 복제 시나리오에 맞춰 번갈아 이용합니다. 마스터가 보유한 상태가 슬레이브에 정확히 전달되려면 오프셋, 부분 동기화 범위, 로그 식별자가 정합돼야 합니다. 그래서 `loadDataFromDisk`로 시작한 서버가 다시 `fullsync` 혹은 `PSYNC`로 이동할 때 어떤 경로를 택하는지가 운영 지연을 좌우합니다.\n\n실행 데이터에서 중요한 것은 객체 단위가 파일 단위로 안전하게 보존되느냐입니다. stream, list, hash, set 같은 타입은 각각 저장/로딩 루틴이 다르므로 작은 변경이 특정 타입만 깨트리는 사례가 흔합니다. `rdbLoad`에서 타입 핸들러가 바뀌면 특정 타입만 복구 실패하는 증상이 발생할 수 있어, 테스트에서 타입별 시나리오를 함께 검증해야 합니다.\n\n`src/module.c`를 거쳐 모듈 타입이 들어오는 경우에는 더 복잡합니다. 모듈 데이터 타입은 core 타입코드만으로는 해석되지 않기 때문에 모듈 라이프사이클과 버전 정보가 반드시 맞아야 합니다. 외부 확장 데이터가 포함된 저장소는 스냅샷과 로그를 모두 고려해 변경 계획을 세워야 하므로, 단일 파일 수정의 범위를 오판하면 안 됩니다.\n\nsec-3의 실무 결론은 요청 처리 후 데이터 이동을 \\"즉시반응 레이어\\"와 \\"장기 보존 레이어\\"로 나누어 보는 것입니다. 즉시반응은 메모리 변화, 장기 보존은 RDB/AOF/복제입니다. 둘 중 하나라도 누락되면 장애 시 증상이 정상 동작처럼 보여도 복구 단계에서 드러납니다."
          },
          {
            "sectionId": "sec-3",
            "subsectionId": "sub-3-3",
            "titleKo": "핵심 기능 구현과 데이터 경로 - 검증과 변경 포인트",
            "objectiveKo": "영속성과 복제에서 쉽게 생기는 회귀를 구분하고 대응한다.",
            "bodyKo": "영속성 검증에서 실수는 테스트를 통과해도 운영에서만 나타나는 형태로 생깁니다. 가장 흔한 예가 부분 동기화 경로입니다. PSYNC 조건이 맞지 않으면 전체 동기화로 떨어지는데, 이때 트래픽이 급증하며 성능이 급락할 수 있습니다. `src/replication.c`의 오프셋/백로그 정책이 핵심이므로 변경 시 반드시 부하가 있는 환경에서 검증해야 합니다.\n\n`rdb`와 `aof`는 같은 데이터셋을 다루더라도 장애 대응 철학이 다릅니다. 따라서 한쪽을 조정한다고 다른 쪽이 자동 보완되는 것이 아닙니다. 정책 변경은 모듈 확장까지 영향을 미칠 수 있어, 특히 `RM_*` API를 쓰는 커스텀 타입이 있는 경우, 모듈 데이터의 저장 가능성까지 확인해야 합니다. 모듈 데이터가 저장되지 않으면 단기적으로는 동작이 정상이더라도 장기 재시작에서 파손이 발생합니다.\n\n검증 포인트를 층위화하면 정확합니다. 1차는 단일 노드 rdb/aof 정합성, 2차는 복제 재동기화, 3차는 클러스터 리샤딩 이동입니다. 특히 2차에서 offset 추적 실패는 로그로 바로 보일 수 있지만, 실제 사용자 요청 오류로 드러나기 전까지 시간이 걸립니다. 따라서 테스트 자동화에서는 복구 시나리오를 강제로 넣는 것이 중요합니다.\n\n`src/cluster.c`와 `src/replication.c`의 상호작용은 때때로 트랜잭션성 경계처럼 보이는데, 사실은 서로 다른 일관성 레이어입니다. 클러스터 리다이렉트는 라우팅 레이어 문제를 해결하고, 복제는 상태 일관성 문제를 해결한다. 두 레이어가 모두 정상이어야 요청 응답과 장기 데이터 정합성이 동시에 성립합니다.\n\n문서 관점에서도 동일 원칙을 적용할 수 있습니다. 모듈이나 영속성 옵션을 변경했다면 관련 변경 사실을 커밋 로그, 테스트 설명, 위키 본문에서 함께 남겨야 같은 기준으로 재현이 가능합니다. 초보자라도 이 부분을 지키면 동일 장애를 팀 차원에서 반복 재현하지 않을 수 있습니다.\n\nsec-3-3의 핵심은 변경 시 \\"영속성 정책 하나를 바꿀 때 복제와 모듈까지 묶어 본다\\"는 습관입니다. 해당 원칙이 있으면 데이터 경로 회귀를 조기에 포착할 수 있습니다."
          }
        ]
      },
      {
        "sectionId": "sec-4",
        "titleKo": "최근 트렌드와 공식 문서 변화",
        "summaryKo": "이 섹션은 최근 180일 기준 릴리스·태그 시그널과 공식 문서 동기화 상태를 함께 보면서, Redis의 공개 운영 리듬이 기능 구현 우선순위에 어떻게 반영되는지 정리한다. 릴리스 지표는 단일 브랜치에서만 나온 값이 아니며, 6.x 안정/보안 라인과 7.x, 8.x 개선 라인이 동시에 보일 때 문서 정합성 정책이 같이 따라가는지 확인해야 한다.",
        "sourcePaths": [
          "__devport__/trends/releases.json",
          "__devport__/trends/tags.json",
          "__devport__/trends/changelog-summary.json",
          "__devport__/official-docs/index.json",
          "src/release.c",
          "utils/releasetools/changelog.tcl"
        ],
        "subsections": [
          {
            "sectionId": "sec-4",
            "subsectionId": "sub-4-1",
            "titleKo": "최근 트렌드와 공식 문서 변화 - 구조와 책임",
            "objectiveKo": "최근 릴리스 지표로 프로젝트의 개발 패턴을 판독한다.",
            "bodyKo": "`__devport__/trends/changelog-summary.json`에는 `release_count: 21`, `tag_count: 120`, `window_days: 180`가 고정되어 있고, 최신 태그 목록에는 `7.2.13`, `7.4.8`, `8.0.6`, `8.2.5`, `8.4.2`, `8.6.0`, `8.4.1`, `8.2.4`, `8.6-rc1`, `8.4.0`가 들어 있다. 이 숫자 조합은 Redis가 장기 메이저 라인(6.2.x, 7.x, 8.x)을 병렬로 운영하면서도 단기 배포 간격이 짧았던 구간을 그대로 반영한다는 뜻이다. 즉, 팀은 한 번의 대규모 발행보다 패치 기반의 반복 확산을 선택해, 변경 반영 속도와 회귀 대응 비용의 밸런스를 맞추고 있다.\\n\\n`__devport__/trends/releases.json`을 보면 2025-08-28 이후 최신 윈도우 내에서 다수 릴리스가 축적되어 있고, 7.2.13, 7.4.8, 8.0.6, 8.2.5, 8.4.2처럼 서로 다른 시그니처의 배포가 짧은 간격으로 정렬된다. 같은 시점의 `__devport__/trends/tags.json`에서도 6.2.14~6.2.21 연속 태그와 7.0-rc 계열이 같이 보이며, 정식 릴리스 외에 후보/예비 라인에서 안정성 신호를 먼저 배치한 뒤 본선으로 흡수하는 패턴이 확인된다. 초보자가 이 패턴을 읽지 못하면 \"최신 기능이 언제 들어왔는지\"를 오해하기 쉽고, 실제 기능 테스트 시점을 잘못 잡는 실수가 난다.\\n\\n코드 반영 관점에서도 트렌드 증거는 단순 통계가 아니다. `src/release.c`의 `redisGitSHA1()`과 `redisBuildId()`는 빌드 ID가 소스 식별자를 직접 반영한다는 점에서, 배포 주기와 빌드 진입점이 매우 결속돼 있음을 보여준다. 따라서 트렌드가 빠른 구간에서는 같은 커밋 조합인지(특히 `snapshot`에 적재된 `commit_sha`)와 빌드 문자열이 어떤 방식으로 바뀌는지를 함께 추적해야 리그레션 대응이 정확해진다.\\n\\n이 섹션의 핵심 판단은 \"릴리스 수의 많음\" 자체가 아니라 \"변경 파이프라인의 정합성\"이다. 120개 태그와 21개 릴리스는 문서, 테스트, 운영 스크립트가 어느 정도 동기화되어야 하는 신호이며, 동기화가 하나라도 늦어지면 문서-코드 괴리가 생긴다. Redis는 초대형 단일 저장소이므로 `snapshot` 기반 증빙과 `sourceDocs`의 근거가 같이 있어야 팀 온보딩과 배포 실패 대응이 안정적이다.\\n\\n요약하면 최근 트렌드는 Redis가 다중 버전 채널을 병행하며 릴리스를 밀어붙이는 조직 특성을 보여준다. 그 과정에서 중요한 것은 \"얼마나 많이 릴리스했는가\"가 아니라 \"각 릴리스의 문서/테스트/배포 링크가 서로 추적 가능한가\"이다. 따라서 엔지니어는 신규 변경 전에 `__devport__/trends/changelog-summary.json`의 기준 구간으로 현재 페이스를 먼저 읽고, 이어서 `src/` 핵심 파일의 상태와 `tests/` 계층 테스트를 이어가야 한다."
          },
          {
            "sectionId": "sec-4",
            "subsectionId": "sub-4-2",
            "titleKo": "최근 트렌드와 공식 문서 변화 - 실행/데이터 흐름",
            "objectiveKo": "공식 문서·릴리스 변동이 코드 경로에 미치는 연동 지점을 정리한다.",
            "bodyKo": "릴리스 자동화는 Redis에서 `utils/releasetools/*`가 담당한다. `utils/releasetools/changelog.tcl`은 브랜치와 버전, 최근 커밋 로그를 템플릿(`Redis %ver% Released %date%`) 기반으로 붙여 릴리스 노트 문장을 생성하고, `01_create_tarball.sh`는 `git archive`로 `/tmp/redis-${TAG}.tar.gz`를 만든다. 여기에 `02_upload_tarball.sh`가 직접 운영 호스트로 업로드하고, 배포 검증이 끝난 뒤 `redis-stable` 생성물과 `sha256`을 갱신한다. 실제 데이터 흐름은 `03_test_release.sh`에서 tarball을 받아 풀고 `./runtest`, `./runtest-sentinel`, `./runtest-cluster`, `./runtest-moduleapi`를 모두 수행해 배포 전후 실행 검증을 강제한다는 점이다.\\n\\n이후 `04_release_hash.sh`는 `redis-hashes/README`에 해시 항목을 쌓아 배포 산출물의 추적성을 보존한다. 즉, 릴리스 문장 생성(`changelog.tcl`) -> 아카이브 생성(`01_create_tarball`) -> 배포 업로드/배포 정합(`02_upload_tarball`) -> 재배포 전 테스트(`03_test_release`) -> 체크섬 확정(`04_release_hash`)으로 이어지는 직선형 경로가 아니라, 실행 지점이 분기됐다가 다시 묶이는 체인으로 설계돼 있다. 이 체인은 데이터(아티팩트)와 메타데이터(해시/릴리스 노트) 모두를 한 번에 묶기 때문에 운영 사건 분석이 단일 로그보다 훨씬 쉽게 된다.\\n\\n릴리스 이벤트는 `src/mkreleasehdr.sh`에서 `release.h`를 갱신하는 방식과 연결된다. 스냅샷 경로에서 `REDIS_GIT_SHA1`, `REDIS_GIT_DIRTY`, `REDIS_BUILD_ID`가 재컴파일 신호로 반영되고 `src/release.c`에서 `redisBuildIdString()` 같은 출력 형식으로 노출된다. 즉, 릴리스 파이프라인은 패키지 생성만이 아니라 런타임 진단 문자열까지 덮어쓴다. 그래서 8.x 트렌드 구간에서 배포 주기가 빠를수록, 빌드 문자열이 요청되는 `INFO` 계열 진단에서 정확한 버전 식별이 매우 중요해진다.\\n\\n`releasetools` 흐름은 GitHub 액션인 `.github/workflows/redis_docs_sync.yaml`과도 맞물린다. 릴리스 공개(`release: [published]`) 시점에 최신 릴리스 태그를 읽고 `redis/docs` 워크플로를 호출해 공식 문서 동기화를 트리거한다. 즉 릴리스 자동화가 단독 실행되지 않고, docs 동기화와의 상호작용을 보장하는 이벤트 구조 안에서 돌아간다. 이 점은 트렌드 분석에서 릴리스 템포를 평가할 때 \"문서 갱신 지연\"을 반드시 고려해야 한다는 의미로 이어진다.\\n\\n섹션 4-2가 제시하는 결론은 간단하다. 릴리스 관련 코드 경로는 기능 동작과 분리되지 않는다. `changelog`, `tarball`, `test`, `hash`, `docs sync`는 각각 다른 파일에 있지만, 실제 운영에서 하나의 데이터 흐름으로 동작한다. 따라서 변경자는 release 트렌드를 읽을 때 해당 단계의 전 구간을 함께 점검해야 하며, 특정 단계만 수정해 놓고 나머지를 그대로 두면 추적 불가능한 상태가 된다."
          },
          {
            "sectionId": "sec-4",
            "subsectionId": "sub-4-3",
            "titleKo": "최근 트렌드와 공식 문서 변화 - 검증과 변경 포인트",
            "objectiveKo": "문서와 기능 구현의 정합성을 유지하는 검증 프레임을 제시한다.",
            "bodyKo": "공식 문서 동기화 근거는 `__devport__/official-docs/index.json`에서 가장 직접적으로 읽을 수 있다. 현재 `discovery_mode`가 `auto`이고, `discovered_count: 20` 중 `mirrored_count: 12`로 집계되는 점은 링크 추출 자체는 활발하지만 미러링 성공률이 100%가 아님을 뜻한다. 실제 `docs` 배열을 보면 `source_url`에 `.md` 링크가 실패 형태로 저장되는 항목도 `fetch-failed`로 남는데, 이 경우 `mirror_path`가 `null`로 표기된다. 즉 문서 소스가 존재하지 않더라도 파싱과 위키 동기화는 계속되므로 문서 경로 신뢰성은 별도로 관리되어야 한다.\\n\\n`__devport__/official-docs/doc-09.md`, `doc-12.md`, `doc-14.md`처럼 `mirrored` 상태가 유지되는 항목은 저장소와의 연동이 상대적으로 안정적이다. 반대로 `brew.sh` 계열, `cloud.redis.io` 변형, CMake 버전 변수 포함 URL 등은 미러 생성이 실패하는 경우가 보여, 공식 문서가 완전한 truth 소스가 아닐 수 있음을 증명한다. 이 부분이 가장 중요한 트렌드 신호다. 기능 코드가 `src/cluster.c`처럼 자주 변경되는 반면 문서 미러가 실패하면 팀은 실제 동작을 기준으로 문서를 교차검증해야 한다.\\n\\n문서 동기화 실패 가능성은 릴리스 지표와 합쳐질 때 더 중요해진다. 180일 윈도우에서 릴리스 빈도가 높으면 변경 내용이 빨리 쌓이고, docs sync 트리거도 빨라진다. 그런데 미러된 URL의 40%가 누락되거나 파싱 실패를 보이면, 사용자/운영 가이드가 실시간으로 멈춤 없이 갱신되지 않을 수 있다. 따라서 코드 리뷰 단계에서 `__devport__/official-docs/index.json`의 `mirrored_count`를 확인하고, `source_url`이 깨지는 패턴을 발견하면 `REDISCONTRIBUTIONS`나 외부 문서 경로가 아닌 코드 주석/README로 보완하는 전략이 필요하다.\\n\\n실무 검증 프레임을 정리하면 다음이다. 첫째, 변경 대상 기능이 특정 릴리스 트렌드 구간(예: `8.6.0`, `8.4.2`, `8.2.4`)과 겹치는지 확인한다. 둘째, `__devport__/official-docs/index.json`에서 동일 구간의 `mirrored_count`·`discovery_mode`를 확인해 문서 신뢰도를 산출한다. 셋째, `trend_fact_count`가 제시한 8개 항목과 기존 `trendFacts`를 비교해 문서 동기화 실패 여부를 서술적으로 기록한다. 넷째, `sourceDocs`에 실제 증거 경로를 유지하고, `package` 단계에서 자동 생성한 용어색인에 반영한다. 이 4단을 지키면 릴리스 급변기에도 문서와 코드의 편차를 줄일 수 있다.\\n\\n요약하면 공식 문서 트렌드는 단독으로 보는 지표가 아니라 릴리스 데이터와 결합된 운영 지표다. `__devport__/trends/*`는 \"무엇이 바뀌었는지\"를 알려주고, `__devport__/official-docs/index.json`은 \"무엇이 사용자에게 도달했는지\"를 알려준다. 둘 사이의 공백이 크면 위키 본문에서 반드시 경고와 보완 포인트를 남겨야 하며, 초보자 기준에서는 이 지점이 가장 먼저 체크되는 부분이다."
          }
        ]
      },
      {
        "sectionId": "sec-5",
        "titleKo": "검증 전략과 운영 품질 게이트",
        "summaryKo": "Redis는 기능 변경보다 테스트 전략이 먼저 오판을 막는다. 섹션 5는 `tests/` 계층 구조를 기준으로 어떤 변경이 어떤 게이트를 통과해야 하는지, 그리고 실패가 발생했을 때 가장 먼저 어디를 추적해야 하는지 정리한다.",
        "sourcePaths": [
          "tests/unit/cluster/slot-stats.tcl",
          "tests/unit/acl.tcl",
          "tests/unit/cluster/atomic-slot-migration.tcl",
          "tests/integration/replication.tcl",
          "tests/integration/aof.tcl",
          "tests/unit/type/hash-field-expire.tcl"
        ],
        "subsections": [
          {
            "sectionId": "sec-5",
            "subsectionId": "sub-5-1",
            "titleKo": "검증 전략과 운영 품질 게이트 - 구조와 책임",
            "objectiveKo": "Redis 테스트 계층의 기본 목적과 검증 범위를 한눈에 정리한다.",
            "bodyKo": "테스트 구조의 시작점은 `tests/README.md`에 정의된 태그 체계다. 단위 테스트는 기본 동작 정합성을 점검하고, 통합 테스트는 실제 서버 상호작용에서의 충돌을 잡는다. `tests/unit`은 `external:skip`, `cluster:skip`, `needs:repl` 같은 태그로 실행 제약을 걸 수 있고, `tests/integration`은 노드 이동, 복제, 멀티노드 조건에서 리턴값과 동시성 특성을 검증한다. 즉, 테스트를 단편적으로 볼 수 없고 태그-컨텍스트 조합을 함께 봐야 한다.\\n\\n`tests/integration/replication.tcl`를 중심으로 보면 `slaveof`, `wait_for_ofs_sync`, `rdb-key-save-delay`, `master-link` 상태가 변화하는 구간이 반복 검증 대상이다. 특히 replication 관련 실패 시 `replication` 경계에서 응답이 지연되거나 `timeout connecting` 같은 로그가 늦게 생기는지 관찰한다. 같은 시점에서 `tests/unit/cluster` 쪽은 슬롯 이동과 리다이렉트 동작을 별도로 다루므로, 어떤 수정이 단위 레이어에서 보이지 않고 통합 레이어에서만 깨지는지 구조적으로 확인할 수 있다. 초보자가 자주 놓치는 포인트는 여기서 `cluster-mode`와 `external` 태그를 무시해 테스트가 다른 환경에서 다른 결과를 내는 경우다.\\n\\n`src/commands/`의 API 변경은 보통 `tests/unit/acl.tcl`, `tests/unit/type/hash-field-expire.tcl`와 같은 인접 테스트에서 우선 드러난다. ACL 변경은 단순 `ACL SETUSER` 동작만 보는 게 아니라 `COMMAND`, `KEYS`, 채널 권한, 네트워크 상 응답 코드 문자열(`WRONGPASS`, `NOPERM`)까지 범위를 확장해 검증해야 한다. 따라서 `sec-5`의 기본 원칙은 \"테스트 파일 1개로 판단하지 않는다\"다. 하나의 변경은 최소 2~3개 컨텍스트에서, 특히 태그가 바뀌는 컨텍스트까지 함께 재현해야 실제 품질 게이트가 성립한다.\\n\\n품질 게이트를 실제로 운영하기 위해서는 `runtest` 실행 옵션(`--cluster-mode`, `--singledb`, `--host`, `--port`) 조합이 의미가 있다. 외부 서버에서 돌릴 때는 `external:skip` 태그가 자동 건너뛰기되는 특성을 이해해야 하며, 로컬 단일 모드에서는 `large-memory`, `tls` 같은 태그가 가리키는 제약을 감안해야 한다. 예를 들어 replication 경로만 바꿨는데 cluster나 large-memory 태그를 끊어두면, 실제 트래픽에서 재현될 실패를 테스트에서 놓치기 쉽다.\\n\\n결국 검증은 \"변경 항목 리스트\"를 먼저 세운 뒤, 태그 행렬에 따라 최소 경로를 보장하는 방식으로 설계해야 한다. Redis의 경우 변경당 기본 경로를 세우면 단기적으로 30~50% 실패를 걸러낼 수 있다. 게이트를 수치화하면 `unit coverage + integration smoke + 관련 feature tests`의 조합이 되고, 이 조합에서 PASS 되면 운영 단계에서 추가 예외를 붙이더라도 확률을 낮출 수 있다."
          },
          {
            "sectionId": "sec-5",
            "subsectionId": "sub-5-2",
            "titleKo": "검증 전략과 운영 품질 게이트 - 실행/데이터 흐름",
            "objectiveKo": "실행 계층 중심의 게이트를 정의하고 통과 기준을 구체화한다.",
            "bodyKo": "운영 품질 게이트에서 가장 많이 쓰는 경로는 `tests/unit/cluster/atomic-slot-migration.tcl`와 `tests/unit/cluster/slot-stats.tcl`다. 슬롯 마이그레이션 테스트는 `slot_key`, `slot_prefixes`, `CLUSTER MIGRATION IMPORT`, `migration_status` 패턴을 통해 슬롯 이동 상태가 실제로 전이되는지를 확인한다. 이 테스트는 노드 간 상태를 동기화된 방식으로 옮기는지, 이동 중 쓰기/append가 누락되는지까지 직접 관찰할 수 있어, 라우팅 버그를 조기에 잡는 데 유용하다.\\n\\n`tests/integration/replication.tcl`에서는 핸드셰이크, 핸드셰이크 실패 처리, `replication offset` 재동기화 루틴이 핵심이다. `wait_for_condition`으로 `master_link_status`와 `role` 상태를 비교하고, 타임아웃과 재시작 시나리오를 반복한다. 이 경로는 실제 운영에서 가장 빈번하게 오탐/락스락을 만들 수 있으므로, 재현 테스트가 꼭 필요하다. 단일 노드에서 성공해도 멀티 노드로 넘어가면 실패가 드러나는 대표 구간이다.\\n\\n`tests/integration/aof.tcl`는 AOF 손상·부분 손상 경로까지 다룬다. `short read`, `Unexpected end of file`, `Bad file format` 같은 메시지 케이스를 확인하고, `redis-check-aof --fix`가 복구 가능한지까지 체크한다. 이 테스트의 의미는 단순히 AOF가 정상 저장되는지를 넘어서 \"복구 실패를 어떻게 감지하고 복구를 결정할지\"까지 포함한다. 운영 중에 가장 치명적인 문제 중 하나가 파일 시스템 손상인데, 이 경로가 빠진 상태로 배포를 진행하면 장애 복구가 지연된다.\\n\\n이 세 테스트 집합을 한 번에 묶으면 데이터 입력 경로(슬롯/클러스터), 상태 동기화 경로(복제), 영속성 보존 경로(AOF)가 한 루프에서 걸러진다. 즉, 변경 항목이 `src/replication.c`인지 `src/cluster.c`인지에 따라 실행 순서를 정하면 된다. 먼저 슬롯 이동 단에서 `tests/unit/cluster`, 다음에 `tests/integration/replication`, 마지막으로 `tests/integration/aof` 순으로 돌려도 되지만, 역순이 아니라 상위 의존성 순서가 중요하다. 왜냐하면 AOF 실패를 먼저 잡아도 라우팅이 이미 깨진 상태면 원인 귀속이 뒤섞이기 때문이다.\\n\\n품질 게이트의 실무 규칙은 간단하다. 변경이 데이터 경로라면 반드시 `tests/integration/aof.tcl`를 넣고, 클러스터라면 `tests/unit/cluster/*`를 우선 넣는다. 둘 다 변경되면 `tests/integration/replication.tcl`로 전이해야 한다. 섹션 5의 결론은 \"테스트 집합이 많을수록 불필요한 비용이 아니라 배포 보험료\"이며, `snapshot` 기반 위키 문서에서 근거 경로를 명시하면 팀 멤버가 재현 루틴을 쉽게 따라간다."
          },
          {
            "sectionId": "sec-5",
            "subsectionId": "sub-5-3",
            "titleKo": "검증 전략과 운영 품질 게이트 - 검증과 변경 포인트",
            "objectiveKo": "회귀를 유도하는 지점을 추적하는 운영 점검표를 제시한다.",
            "bodyKo": "회귀 추적은 원인 후보를 좁히는 지도에서 시작한다. 첫 번째 후보는 라우팅이다. 클러스터 환경에서 `MOVED`, `ASK`, 슬롯 마이그레이션 관련 상태, `slot_stats`가 바뀐다면 `tests/unit/cluster/slot-stats.tcl`과 `tests/unit/cluster/atomic-slot-migration.tcl`에서 패턴이 유지되는지 먼저 본다. 클러스터 테스트는 빠르게 `cluster-response` 불일치나 슬롯 오판을 보여주므로 가장 초기 필터로 사용한다.\\n\\n두 번째 후보는 보안·접근 제어다. `tests/unit/acl.tcl`에서 기본 사용자의 동작이 바뀌었거나 권한 토픽이 이동했다면 문서화와 권한 테스트를 모두 재실행해야 한다. `ACL SETUSER`, `WHOAMI`, 채널 접근 패턴은 한 번 깨지면 단위로 잘 드러나지 않는 버그가 API로 확산될 수 있기 때문이다. ACL 실패는 보통 초반에 눈에 띄지만, 실제 영향은 인증 경로의 특정 사용자 패턴에서만 발생한다.\\n\\n세 번째 후보는 영속성이다. AOF나 RDB 경로를 건드리지 않았다고 해도, 설정값 변경이나 함수 호출 경로 변경이 복제 백로그와 오프셋 동기화에 간접 영향을 미칠 수 있다. 이때 `tests/integration/aof.tcl`와 `tests/integration/replication.tcl`의 조합으로 \"쓰기 -> fsync -> 동기화\"를 같이 본다. 특히 `appendonly`가 켜진 상태에서 실패한 케이스가 누락되면 실제 장애 복구 때만 드러나기 때문에 운영 리스크가 크다.\\n\\n네 번째 후보는 문서 동기화다. 공식 문서 미러는 릴리스와 함께 진화한다는 점이 분명하므로, 품질 게이트 표에는 코드만이 아니라 `__devport__/official-docs/index.json`의 미러 성공률도 포함해야 한다. 문서 미러가 떨어진 기능이라도 테스트가 통과했더라도 사용자 가이드는 틀릴 수 있으므로, 운영 품질은 문서 정확성의 측정치를 가져야 한다. 이 원칙은 `src/commands/README.md` 같은 레퍼런스 문서를 함께 정리할 때 특히 중요하다.\\n\\n최종적으로 운영 점검표는 매 변경에 대해 \"기능 동작", "클러스터 정합성", "영속성 경로", "문서 도달성"의 4개 차원을 갖는다. 각 차원이 최소 하나의 테스트 또는 증거 파일에 매핑되지 않으면 패키징 단계에서 다시 문턱 아래로 내려가야 한다. 이 과정을 습관화하면 팀 내부에서 반복적으로 같은 회귀를 다시 작성하는 비용을 줄이고, `DEVPORT` 파이프라인에서 신뢰도를 높일 수 있다."
          }
        ]
      },
      {
        "sectionId": "sec-6",
        "titleKo": "확장 포인트와 기여 가이드",
        "summaryKo": "이 섹션은 Redis에 기여할 때 가장 자주 걸리는 지점인 모듈 확장, 문서 동기화, 테스트 갱신을 단일 흐름으로 정리한다. 변경자는 `README`와 `CONTRIBUTING`을 먼저 읽은 뒤, 테스트 경로와 릴리스 경로를 함께 맞춘다.",
        "sourcePaths": [
          "CONTRIBUTING.md",
          "REDISCONTRIBUTIONS.txt",
          "src/module.c",
          "src/commands/README.md",
          "tests/README.md",
          "utils/create-cluster/README"
        ],
        "subsections": [
          {
            "sectionId": "sec-6",
            "subsectionId": "sub-6-1",
            "titleKo": "확장 포인트와 기여 가이드 - 구조와 책임",
            "objectiveKo": "확장 포인트의 의도와 기여 접근 순서를 정한다.",
            "bodyKo": "기여의 첫 단계는 코드 변경이 아니라 규칙 확인이다. `CONTRIBUTING.md`는 Redis 소프트웨어 라이선스 모델, CLA 동의, PR 절차를 명시하고, `REDISCONTRIBUTIONS.txt`는 장기 라이선스 이력을 자세히 다룬다. 즉, 새로운 기여는 기술적 구현 이전에 계약·승인 조건을 분기점으로 통과해야 한다는 뜻이다. 초보 기여자는 여기서 중단되는 경우가 많다.\\n\\n실무적으로는 `major feature`와 `minor fix`를 구분하고, 후자는 바로 브랜치에서 PR로 이어지도록 안내한다. 대형 변경은 메일링 리스트·이슈 정합성 확인을 거친 뒤 PR로 가야 한다는 규칙이 명시돼 있다. 이 점을 지키면 리뷰어가 맥락을 이해하기 쉬워지고, 동일 주제의 중복 논의를 줄일 수 있다.\\n\\n기여 순서는 대체로 `문서 근거 -> 테스트 계획 -> 빌드/테스트 -> PR`이다. Redis는 `README.md`, `src/commands/README.md`, `tests/README.md`를 보면 해당 기능군의 문맥과 API 기대 동작을 알 수 있다. 특히 변경이 문서/예제에 영향을 주면 `__devport__/official-docs` 경로의 미러 상태까지 함께 확인해야 한다. 문서 경로를 건너뛰면 기능이 동작해도 사용자 지도가 틀어질 가능성이 높아진다.\\n\\n또한 `tests` 경로를 선점해야 한다. 기여자는 `tests/unit`에서 최소 한 개 컨텍스트, `tests/integration`에서 핵심 하나를 선택해 증빙을 남겨야 한다. ACL, 클러스터, AOF/복제 중 변경 성격과 가장 가까운 테스트를 고르는 이유는, PR 리뷰 단계에서 변경 범위가 바로 드러나기 때문이다. 이때 실패가 나면 되돌리기 쉬운 단위로 줄이는 습관이 중요하다.\\n\\n기여 체크리스트를 정리하면 이렇다. 첫째, 라이선스와 기여 조건 확인. 둘째, 대상 모듈/명령의 실행/테스트 근거 수집. 셋째, 문서 경로 영향 점검. 넷째, 릴리스 파이프라인과 충돌 가능성 검토. 다섯째, CI에서 동일 신호가 재현되는지 확인. 이런 절차가 있으면 초보자도 코드 추가에서 회귀 신고까지를 빠르게 수행할 수 있다."
          },
          {
            "sectionId": "sec-6",
            "subsectionId": "sub-6-2",
            "titleKo": "확장 포인트와 기여 가이드 - 실행/데이터 흐름",
            "objectiveKo": "모듈/API 수정 시 데이터 경로 변경이 어떤 순서로 반영되는지 추적한다.",
            "bodyKo": "모듈 확장의 중심은 `src/module.c`다. `RM_RegisterCommand`, `RM_CreateDataType` 같은 모듈 API는 사용자 정의 타입과 커맨드를 서버에 등록하고, 명령 실행 경계에서 기존 `src/commands.c` 규칙과 충돌하지 않도록 한다. 이 경계에서 경합이 생기면 같은 이름, 같은 ACL, 같은 인자 규약으로도 동작이 달라질 수 있다.\\n\\n`src/module.c`를 건드린 뒤 `src/commands/README.md`와 연동되는지 먼저 보는 것이 중요하다. Redis의 명령 파서는 표면적으로 단일 동작처럼 보여도, 모듈이 등록한 데이터 타입이나 콜백이 내부 객체 라이프사이클에 영향을 미치면 복제·영속성 경로까지 파생된다. 특히 `replication` 관련 콜백이 있을 경우 `src/replication.c` 경로에서 재동기화 비용이 급증할 수 있다. 모듈 변경을 단독으로 보는 실수는 리스크가 크다.\\n\\n클러스터 실험 확장은 `utils/create-cluster/README`에서 실행 순서를 잘 보면 된다. 스크립트는 start → create → stop/clean 흐름으로 다중 인스턴스를 띄우고, 수동으로 클러스터를 구성한다. 이 환경은 `atomic-slot-migration.tcl`에서 보이는 슬롯 이동 동작과 결합돼, 모듈이 분산 환경에서 어떤 포인트까지 영향 받는지를 테스트하는 데 유리하다.\\n\\n또 다른 데이터 경로는 릴리스 빌드 메타데이터이다. `src/mkreleasehdr.sh`와 `src/release.c`는 빌드 문자열의 정합성과 캐시 갱신을 담당하기 때문에, 모듈 변경이 빌드 ID 표기와 완전히 무관하다고 가정하면 안 된다. 모듈 코드가 추가되면 실제 배포 산출물 이름/해시/빌드 정보까지 영향이 있을 수 있으므로 릴리스 전후 경로를 같이 확인한다.\\n\\n확장 기여를 위한 실행 지침은 명확하다. 모듈 API를 바꾼 뒤 즉시 단위 테스트, 모듈 API 동작 테스트, 최소 1회의 클러스터 테스트를 연결한다. 그리고 문서/릴리스 메타데이터가 실제 코드와 동기화되었는지 확인해 패키징한다. 이 순서만 지키면 기능 추가가 사용자 관측 지점(명령 응답, 데이터 정합성, 운영 모니터링)까지 자연스럽게 반영된다."
          },
          {
            "sectionId": "sec-6",
            "subsectionId": "sub-6-3",
            "titleKo": "확장 포인트와 기여 가이드 - 검증과 변경 포인트",
            "objectiveKo": "기여 과정에서 리뷰와 검증이 놓치기 쉬운 포인트를 정리한다.",
            "bodyKo": "리뷰에서 가장 흔한 누락은 코드 변경과 테스트·문서 증거의 연결이다. `sec-6`의 관점에서 보면 커밋은 `CONTRIBUTING.md`와 `REDISCONTRIBUTIONS.txt`를 통과했더라도 리뷰어가 물어보는 첫 질문은 `어떤 테스트가 실패를 방지하는가`, `어떤 문서에 영향이 전파되는가`, `릴리스 메타데이터는 갱신되는가`이다. 따라서 PR 본문에 경로 단위 근거를 붙이는 습관이 필요하다.\\n\\n`tests/README.md`의 태그 기준을 다시 보면 외부 서버 실행 여부, cluster 모드 여부, 대용량 메모리 조건을 따로 명시해야 한다. 즉, 수정이 cluster에서만 드러나면 로컬 단일 실행으로 Pass만 받은 채로 PR을 올려도 위험하다. 리뷰 단계에서는 `--cluster-mode`, `--host/--port`, `external:skip` 태그 처리를 분명히 적어야 하며, 실패 재현법(`runtest --tags ...`)도 같이 남긴다.\\n\\n문서 경로도 같은 수준으로 관리한다. `__devport__/official-docs/index.json`에서 공식 문서의 `mirrored_count`가 낮거나 `fetch-failed`가 발생한 항목이 있으면, 위키와 코드 리뷰에서 \"문서 동기화 대기\" 표기를 분명히 둬야 한다. 단순히 링크 깨짐을 넘기면 사용자 질문이 증폭되고, 이후 릴리스에서 같은 문제가 재발한다.\\n\\n변경 포인트 점검표를 고정하면 리뷰 효율이 오른다. 1) 수정 파일이 `src/module.c`, `src/commands.c`, `src/replication.c` 중 어디를 건드리는지, 2) 관련 테스트 파일(`tests/unit/acl.tcl`, `tests/unit/cluster/atomic-slot-migration.tcl`, `tests/integration/replication.tcl`, `tests/integration/aof.tcl`)을 어느 순으로 추가했는지, 3) release/releasetool 연동(`src/release.c`, `utils/releasetools/*`)이 필요한지, 4) 공식문서 미러 상태를 확인했는지, 5) 코드 리뷰어와 사용자에게 필요한 설명이 docs/챕터에 반영되었는지. 이 항목을 빠뜨리면 초보자 기여는 물론 숙련자 PR도 장기적으로 재작업이 늘어난다.\\n\\n최종적으로 `sec-6`은 확장 포인트를 넓게 보되, 검증은 좁은 단위로 닫는 전략을 말한다. 변경한 기능이 잘 동작한다는 사실보다, 그 기능이 어디에 영향을 주었고 어디가 보호되어야 하는지 더 중요하다. 따라서 기여자는 코드, 테스트, 릴리스, 문서의 4개 축을 모두 닫아야 다음 단계로 넘어가야 한다."
          }
        ]
      }
    ],
    "sourceDocs": [
      { "sourceId": "src-01", "path": "README.md" },
      { "sourceId": "src-02", "path": "src/server.c" },
      { "sourceId": "src-03", "path": "src/redis-cli.c" },
      { "sourceId": "src-04", "path": "src/config.c" },
      { "sourceId": "src-05", "path": "src/commands/README.md" },
      { "sourceId": "src-06", "path": "src/commands.c" },
      { "sourceId": "src-07", "path": "src/cluster.c" },
      { "sourceId": "src-08", "path": "src/rdb.c" },
      { "sourceId": "src-09", "path": "src/aof.c" },
      { "sourceId": "src-10", "path": "src/module.c" },
      { "sourceId": "src-11", "path": "src/replication.c" },
      { "sourceId": "src-12", "path": "src/release.c" },
      { "sourceId": "src-13", "path": "deps/README.md" },
      { "sourceId": "src-14", "path": "deps/hiredis/README.md" },
      { "sourceId": "src-15", "path": "deps/hiredis/CHANGELOG.md" },
      { "sourceId": "src-16", "path": "deps/jemalloc/README" },
      { "sourceId": "src-17", "path": "tests/README.md" },
      { "sourceId": "src-18", "path": "__devport__/trends/releases.json" },
      { "sourceId": "src-19", "path": "__devport__/trends/tags.json" },
      { "sourceId": "src-20", "path": "__devport__/trends/changelog-summary.json" },
      { "sourceId": "src-21", "path": "__devport__/official-docs/index.json" },
      { "sourceId": "src-22", "path": "__devport__/official-docs/doc-09.md" },
      { "sourceId": "src-23", "path": "__devport__/official-docs/doc-12.md" },
      { "sourceId": "src-24", "path": "CONTRIBUTING.md" }
    ],
    "trendFacts": [
      { "factId": "trend-1", "category": "release", "summaryKo": "180일 내 릴리스 개수가 증가해, 릴리스 간격이 촘촘하고 작은 기능 단위 반영이 자주 이루어졌다." },
      { "factId": "trend-2", "category": "tagging", "summaryKo": "릴리스 태그뿐 아니라 `8.6.0` 계열처럼 중간 릴리스가 병행되어 배포 속도와 버그픽스 주기가 가깝게 운영되었다." },
      { "factId": "trend-3", "category": "release", "summaryKo": "최근 120개 태그 중 다수는 안정 릴리스와 후보 라벨이 혼합되어, 배포 채널 구분이 문서/운영 정책의 핵심 요소로 작동한다." },
      { "factId": "trend-4", "category": "docs", "summaryKo": "공식문서 미러는 20개 항목 중 12개만 실 콘텐츠로 반영되어, mirror 실패 항목이 존재해 링크 안정성 관리가 필요하다." },
      { "factId": "trend-5", "category": "releasability", "summaryKo": "릴리스 노트와 릴리스 스크립트가 `utils/releasetools`에 함께 유지되어, 배포 자동화가 코드 리뷰와 분리되기보다 코드베이스 안에서 통제된다." },
      { "factId": "trend-6", "category": "quality", "summaryKo": "`8.4.x`~`8.6.0` 구간의 공개 주기 증가가 품질 개선 의존적 배포 전략을 반영하며, 정적 문서 동기화가 함께 빠르게 맞물린다." },
      { "factId": "trend-7", "category": "ecosystem", "summaryKo": "모듈·CLI 기능 변경이 커뮤니티 채널에서 빠르게 반영되지만, 공식 문서 링크와 실제 예제의 정합성 확인이 필요해 트렌드 반영 지연이 생길 수 있다." },
      { "factId": "trend-8", "category": "governance", "summaryKo": "공식 문서/릴리스 동기화가 운영 비용을 크게 좌우하는 구조로, 주기적 릴리스 시점마다 snapshot 기반 근거 문서 점검이 실무 베이스라인이 된다." }
    ]
  }
}
